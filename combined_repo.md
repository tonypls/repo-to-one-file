# Repo as one markdown file

This file was generated by the repo-to-one-file package, find it here:

[GitHub](https://github.com/tonypls/repo-to-one-file)

[pypi](https://pypi.org/project/repo-to-one-file/)

# Directory Structure

```
  combined_repo.md
  LICENSE
  README.md
  setup.py
  .gitignore
.pytest_cache/
    CACHEDIR.TAG
    README.md
    .gitignore
  v/
repo_to_one_file/
    __init__.py
    __main__.py
tests/
    test_repo_to_one_file.py
repo_to_one_file.egg-info/
    PKG-INFO
    SOURCES.txt
    entry_points.txt
    top_level.txt
    dependency_links.txt
```

## README.md

````md
# repo-to-one-file

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT) ![GitHub Repo stars](https://img.shields.io/github/stars/tonypls/repo-to-one-file?style=badge)

repo-to-one-file is a Python tool that consolidates repository files into a single Markdown file. It's designed to create a comprehensive overview of a codebase, which can be particularly useful for documentation or as context for large language models.

[Check out the repo here, please star <3](https://github.com/tonypls/repo-to-one-file)
<br>
[Check out the JavaScript version here](https://github.com/tonypls/repo-to-one-file-cli)

## Features

- Generates a directory structure of the repository
- Consolidates content of specified file types (.py, .js, .ts, .json, etc.) into a single Markdown file
- Ignores common non-source files and directories (node_modules, .git, etc.)
- Configurable maximum line count per file
- Option to include normally ignored files
- Prioritizes important files like README, package.json, requirements.txt, etc.

## Installation

Using pip:

```bash
pip install repo-to-one-file
```
````

or

You can install repo-to-one-file directly from GitHub:

```bash
pip install git+https://github.com/tonypls/repo-to-one-file.git
```

For development, clone the repository and install in editable mode:

```bash
git clone https://github.com/tonypls/repo-to-one-file.git
cd repo-to-one-file
pip install -e .
```

## Usage

After installation, you can use repo-to-one-file from the command line:

```bash
repo-to-one-file
```

This will create a `combined_repo.md` file in the current directory.

### Options

- `--max-lines`: Set the maximum number of lines per file (default: 1000)
- `--include-ignored`: Include files that would normally be ignored

Example:

```bash
repo-to-one-file --max-lines 2000 --include-ignored
```

## Output Format

The generated Markdown file will have the following structure:

1. Directory structure of the repository
2. Content of priority files (README, package.json, requirements.txt, pyproject.toml)
3. Content of other included files (.py, .js, .ts, .json, etc.)

Each file's content is presented under a header with its relative path and enclosed in a code block with the appropriate language tag.

## Ignored Patterns

By default, the tool ignores many common non-source files and directories, including:

- Version control directories (.git, .svn)
- Package manager directories and files (node_modules, package-lock.json)
- Build directories and files (dist, build)
- Cache directories
- Log files
- Environment files
- OS-generated files

For a full list, please refer to the `ignored_patterns` list in the `__main__.py` file.

## Development

To set up the development environment:

1. Clone the repository
2. Install the package in editable mode: `pip install -e .`
3. Install development dependencies: `pip install pytest`

To run tests (once implemented):

```bash
pytest
```

## Contributing

Contributions are welcome! Here are some ways you can contribute:

1. Implement test cases
2. Improve error handling and logging
3. Add support for more file types
4. Optimize performance for large repositories
5. Improve documentation and examples

Please feel free to submit issues and pull requests.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgements

- This project was inspired by the need to provide concise codebase overviews for large language models.
- Thanks to all contributors and users of this tool.

````

## .pytest_cache/README.md

```md
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.

````

## setup.py

```py
from setuptools import setup, find_packages

with open("README.md", "r", encoding="utf-8") as fh:
    long_description = fh.read()

setup(
    name="repo-to-one-file",
    version="1.0.4",
    author="tonypls",
    author_email="tony@appy.co.nz",
    description="A tool to consolidate repository files into a single file",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/tonypls/repo-to-one-file",
    packages=find_packages(exclude=["tests", "tests.*"]),
    classifiers=[
        "Development Status :: 3 - Alpha",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
    ],
    python_requires=">=3.7",
    install_requires=[
        # List your project dependencies here
    ],
    entry_points={
    "console_scripts": [
        "repo-to-one-file=repo_to_one_file.__main__:main",
    ],
},
)
```

## repo_to_one_file/**init**.py

```py
from .__main__ import create_markdown, generate_directory_structure

__version__ = "1.0.4"
__all__ = ['create_markdown', 'generate_directory_structure']

"""
repo-to-one-file: A tool to consolidate repository files into a single Markdown file.

This package provides functionality to:
1. Generate a directory structure of a given repository
2. Create a consolidated Markdown file of the repository contents
"""
```

## repo_to_one_file/**main**.py

````py
import os
import argparse
import fnmatch

def read_file_content(file_path, max_lines):
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            lines = file.readlines()
            if len(lines) > max_lines:
                return f"File exceeds {max_lines} lines. Skipped."
            return ''.join(lines)
    except Exception as e:
        return f"Error reading file: {str(e)}"

def get_language(file_path):
    extension = os.path.splitext(file_path)[1][1:]
    return extension if extension else 'text'

def should_include(filename, relative_path, ignored_patterns):
    if any(fnmatch.fnmatch(relative_path, pattern) for pattern in ignored_patterns):
        return False
    return (filename.lower() == 'readme.md' or
            filename in ['package.json', 'requirements.txt', 'pyproject.toml'] or
            filename.endswith('.py') or
            filename.endswith('.js') or filename.endswith('.jsx') or
            filename.endswith('.ts') or filename.endswith('.tsx') or
            filename.endswith('.json'))

def generate_directory_structure(repo_path, ignored_patterns):
    structure = []
    for root, dirs, files in os.walk(repo_path):
        level = root.replace(repo_path, '').count(os.sep)
        indent = '  ' * level
        folder_name = os.path.basename(root)
        if level > 0:  # Don't add the root directory itself
            structure.append(f'{indent[:-2]}{folder_name}/')

        subindent = '  ' * (level + 1)
        for file in files:
            relative_path = os.path.relpath(os.path.join(root, file), repo_path)
            if not any(fnmatch.fnmatch(relative_path, pattern) for pattern in ignored_patterns):
                structure.append(f'{subindent}{file}')

        # Prune ignored directories
        dirs[:] = [d for d in dirs if not any(fnmatch.fnmatch(d, pattern) for pattern in ignored_patterns)]

    return '\n'.join(structure)

def create_markdown(repo_path, output_file, max_lines, ignored_patterns):
    with open(output_file, 'w', encoding='utf-8') as out_file:
        out_file.write("# Repo as one markdown file\n\n")
        out_file.write( "This file was generated by the repo-to-one-file package, find it here: \n\n [GitHub](https://github.com/tonypls/repo-to-one-file) \n\n [pypi](https://pypi.org/project/repo-to-one-file/)\n\n")
        # Add directory structure
        out_file.write("# Directory Structure\n\n```\n")

        out_file.write(generate_directory_structure(repo_path, ignored_patterns))
        out_file.write("\n```\n\n")

        # First, add README, package.json, or equivalent
        priority_files = ['readme.md', 'package.json', 'requirements.txt', 'pyproject.toml']
        for root, _, files in os.walk(repo_path):
            for file in sorted(files):
                relative_path = os.path.relpath(os.path.join(root, file), repo_path)
                if file.lower() in priority_files and should_include(file, relative_path, ignored_patterns):
                    file_path = os.path.join(root, file)
                    content = read_file_content(file_path, max_lines)
                    language = get_language(file_path)
                    out_file.write(f"## {relative_path}\n\n```{language}\n{content}\n```\n\n")

        # Then, add all .py, .js*, .ts*, and .json files
        for root, _, files in os.walk(repo_path):
            for file in sorted(files):
                relative_path = os.path.relpath(os.path.join(root, file), repo_path)
                if should_include(file, relative_path, ignored_patterns) and file.lower() not in priority_files:
                    file_path = os.path.join(root, file)
                    content = read_file_content(file_path, max_lines)
                    language = get_language(file_path)
                    out_file.write(f"## {relative_path}\n\n```{language}\n{content}\n```\n\n")

def main():
    parser = argparse.ArgumentParser(description="Consolidate repository files into a single Markdown file.")
    parser.add_argument("--max-lines", type=int, default=1000, help="Maximum number of lines per file (default: 1000)")
    parser.add_argument("--include-ignored", action="store_true", help="Include files that would normally be ignored")

    args = parser.parse_args()

    repo_path = os.getcwd()
    output_file = "combined_repo.md"

    ignored_patterns = [
    "node_modules*", "package-lock.json", "npm-debug.log", "yarn.lock", "yarn-error.log",
    "pnpm-lock.yaml", "bun.lockb", "deno.lock", "vendor", "composer.lock",
    "__pycache__", "*.pyc", "*.pyo", "*.pyd", ".Python", "pip-log.txt",
    "pip-delete-this-directory.txt", ".venv", "venv", "ENV", "env",
    "Gemfile.lock", ".bundle", "target", "*.class", ".gradle", "build",
    "pom.xml.tag", "pom.xml.releaseBackup", "pom.xml.versionsBackup", "pom.xml.next",
    "bin", "obj", "*.suo", "*.user", "go.sum", "Cargo.lock",
    ".git", ".svn", ".hg", ".DS_Store", "Thumbs.db",
    ".env", ".env.local", ".env.development.local", ".env.test.local", ".env.production.local",
    "*.env", "*.env.*", ".svelte-kit", ".next", ".nuxt", ".vuepress", ".cache", "dist", "tmp",
    "cache*", "venv*", ".expo*",
    # Additional common files to ignore
    "*.com", "*.dll", "*.exe", "*.o", "*.so",
    # Packages
    "*.7z", "*.dmg", "*.gz", "*.iso", "*.jar", "*.rar", "*.tar", "*.zip",
    # Logs and databases
    "*.log", "*.sql", "*.sqlite",
    # OS generated files
    ".DS_Store?", "._*", ".Spotlight-V100", ".Trashes", "ehthumbs.db"
]

    if args.include_ignored:
        ignored_patterns = []

    create_markdown(repo_path, output_file, args.max_lines, ignored_patterns)
    print(f"Markdown file created: {output_file}")

if __name__ == "__main__":
    main()
````

## tests/test_repo_to_one_file.py

```py
import os
import tempfile
import shutil
import pytest
from repo_to_one_file.__main__ import create_markdown, generate_directory_structure


@pytest.fixture
def temp_repo():
    # Create a temporary directory
    temp_dir = tempfile.mkdtemp()

    # Create some sample files and directories
    os.makedirs(os.path.join(temp_dir, "src"))
    os.makedirs(os.path.join(temp_dir, "tests"))
    os.makedirs(os.path.join(temp_dir, "node_modules"))  # Add this line

    with open(os.path.join(temp_dir, "README.md"), "w") as f:
        f.write("# Test Repository\n\nThis is a test repository.")

    with open(os.path.join(temp_dir, "src", "main.py"), "w") as f:
        f.write("def main():\n    print('Hello, World!')")

    with open(os.path.join(temp_dir, "tests", "test_main.py"), "w") as f:
        f.write("def test_main():\n    assert True")

    # Create a file that should be ignored
    with open(os.path.join(temp_dir, "node_modules", "some_module.js"), "w") as f:
        f.write("console.log('This should be ignored');")

    yield temp_dir

    # Cleanup the temporary directory
    import shutil
    shutil.rmtree(temp_dir)

def test_generate_directory_structure(temp_repo):
    ignored_patterns = ["node_modules*"]
    structure = generate_directory_structure(temp_repo, ignored_patterns)

    assert "README.md" in structure
    assert "src/" in structure
    assert "main.py" in structure
    assert "tests/" in structure
    assert "test_main.py" in structure
    assert "node_modules" not in structure

    # Print the structure for debugging
    print("Generated structure:")
    print(structure)

def test_create_markdown(temp_repo):
    ignored_patterns = ["node_modules*"]
    output_file = os.path.join(temp_repo, "output.md")

    create_markdown(temp_repo, output_file, 1000, ignored_patterns)

    assert os.path.exists(output_file)

    with open(output_file, "r") as f:
        content = f.read()

    assert "# Directory Structure" in content
    assert "## README.md" in content
    assert "## src/main.py" in content
    assert "## tests/test_main.py" in content
    assert "node_modules" not in content

def test_max_lines_limit(temp_repo):
    ignored_patterns = ["node_modules*"]
    output_file = os.path.join(temp_repo, "output.md")

    # Create a file with more than 5 lines
    with open(os.path.join(temp_repo, "long_file.py"), "w") as f:
        f.write("\n".join([f"print({i})" for i in range(10)]))

    create_markdown(temp_repo, output_file, 5, ignored_patterns)

    with open(output_file, "r") as f:
        content = f.read()

    assert "File exceeds 5 lines. Skipped." in content

if __name__ == "__main__":
    pytest.main()
```

## build/lib/repo_to_one_file/**init**.py

```py
from .__main__ import create_markdown, generate_directory_structure

__version__ = "1.0.4"
__all__ = ['create_markdown', 'generate_directory_structure']

"""
repo-to-one-file: A tool to consolidate repository files into a single Markdown file.

This package provides functionality to:
1. Generate a directory structure of a given repository
2. Create a consolidated Markdown file of the repository contents
"""
```

## build/lib/repo_to_one_file/**main**.py

````py
import os
import argparse
import fnmatch

def read_file_content(file_path, max_lines):
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            lines = file.readlines()
            if len(lines) > max_lines:
                return f"File exceeds {max_lines} lines. Skipped."
            return ''.join(lines)
    except Exception as e:
        return f"Error reading file: {str(e)}"

def get_language(file_path):
    extension = os.path.splitext(file_path)[1][1:]
    return extension if extension else 'text'

def should_include(filename, relative_path, ignored_patterns):
    if any(fnmatch.fnmatch(relative_path, pattern) for pattern in ignored_patterns):
        return False
    return (filename.lower() == 'readme.md' or
            filename in ['package.json', 'requirements.txt', 'pyproject.toml'] or
            filename.endswith('.py') or
            filename.endswith('.js') or filename.endswith('.jsx') or
            filename.endswith('.ts') or filename.endswith('.tsx') or
            filename.endswith('.json'))

def generate_directory_structure(repo_path, ignored_patterns):
    structure = []
    for root, dirs, files in os.walk(repo_path):
        level = root.replace(repo_path, '').count(os.sep)
        indent = '  ' * level
        folder_name = os.path.basename(root)
        if level > 0:  # Don't add the root directory itself
            structure.append(f'{indent[:-2]}{folder_name}/')

        subindent = '  ' * (level + 1)
        for file in files:
            relative_path = os.path.relpath(os.path.join(root, file), repo_path)
            if not any(fnmatch.fnmatch(relative_path, pattern) for pattern in ignored_patterns):
                structure.append(f'{subindent}{file}')

        # Prune ignored directories
        dirs[:] = [d for d in dirs if not any(fnmatch.fnmatch(d, pattern) for pattern in ignored_patterns)]

    return '\n'.join(structure)

def create_markdown(repo_path, output_file, max_lines, ignored_patterns):
    with open(output_file, 'w', encoding='utf-8') as out_file:
        # Add directory structure
        out_file.write("# Directory Structure\n\n```\n")
        out_file.write(generate_directory_structure(repo_path, ignored_patterns))
        out_file.write("\n```\n\n")

        # First, add README, package.json, or equivalent
        priority_files = ['readme.md', 'package.json', 'requirements.txt', 'pyproject.toml']
        for root, _, files in os.walk(repo_path):
            for file in sorted(files):
                relative_path = os.path.relpath(os.path.join(root, file), repo_path)
                if file.lower() in priority_files and should_include(file, relative_path, ignored_patterns):
                    file_path = os.path.join(root, file)
                    content = read_file_content(file_path, max_lines)
                    language = get_language(file_path)
                    out_file.write(f"## {relative_path}\n\n```{language}\n{content}\n```\n\n")

        # Then, add all .py, .js*, .ts*, and .json files
        for root, _, files in os.walk(repo_path):
            for file in sorted(files):
                relative_path = os.path.relpath(os.path.join(root, file), repo_path)
                if should_include(file, relative_path, ignored_patterns) and file.lower() not in priority_files:
                    file_path = os.path.join(root, file)
                    content = read_file_content(file_path, max_lines)
                    language = get_language(file_path)
                    out_file.write(f"## {relative_path}\n\n```{language}\n{content}\n```\n\n")

def main():
    parser = argparse.ArgumentParser(description="Consolidate repository files into a single Markdown file.")
    parser.add_argument("--max-lines", type=int, default=1000, help="Maximum number of lines per file (default: 1000)")
    parser.add_argument("--include-ignored", action="store_true", help="Include files that would normally be ignored")

    args = parser.parse_args()

    repo_path = os.getcwd()
    output_file = "combined_repo.md"

    ignored_patterns = [
    "node_modules*", "package-lock.json", "npm-debug.log", "yarn.lock", "yarn-error.log",
    "pnpm-lock.yaml", "bun.lockb", "deno.lock", "vendor", "composer.lock",
    "__pycache__", "*.pyc", "*.pyo", "*.pyd", ".Python", "pip-log.txt",
    "pip-delete-this-directory.txt", ".venv", "venv", "ENV", "env",
    "Gemfile.lock", ".bundle", "target", "*.class", ".gradle", "build",
    "pom.xml.tag", "pom.xml.releaseBackup", "pom.xml.versionsBackup", "pom.xml.next",
    "bin", "obj", "*.suo", "*.user", "go.sum", "Cargo.lock",
    ".git", ".svn", ".hg", ".DS_Store", "Thumbs.db",
    ".env", ".env.local", ".env.development.local", ".env.test.local", ".env.production.local",
    "*.env", "*.env.*", ".svelte-kit", ".next", ".nuxt", ".vuepress", ".cache", "dist", "tmp",
    "cache*", "venv*", ".expo*",
    # Additional common files to ignore
    "*.com", "*.dll", "*.exe", "*.o", "*.so",
    # Packages
    "*.7z", "*.dmg", "*.gz", "*.iso", "*.jar", "*.rar", "*.tar", "*.zip",
    # Logs and databases
    "*.log", "*.sql", "*.sqlite",
    # OS generated files
    ".DS_Store?", "._*", ".Spotlight-V100", ".Trashes", "ehthumbs.db"
]

    if args.include_ignored:
        ignored_patterns = []

    create_markdown(repo_path, output_file, args.max_lines, ignored_patterns)
    print(f"Markdown file created: {output_file}")

if __name__ == "__main__":
    main()
````
